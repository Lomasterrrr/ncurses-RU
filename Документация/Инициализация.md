# 4. Инициализация
Теперь мы знаем, что для инициализации системы `curses` необходимо вызвать
функцию `initscr()`. Есть функции, которые могут быть вызваны после этой
инициализации для настройки нашей сессии `curses`. Мы можем попросить систему
curses установить терминал в `raw` режим, инициализировать цвет, инициализировать
мышь и т.д.. Давайте обсудим некоторые функции, которые обычно вызываются сразу
после `initscr();`

## 4.1. Функции инициализации
## 4.2. raw() и cbreak()
Обычно драйвер терминала буферизирует символы, набираемые пользователем, пока
не встретится новая строка или возврат каретки. Но большинство программ требуют,
чтобы символы были доступны сразу после того, как пользователь их набрал.
Приведенные выше две функции используются для отключения буферизации строки.  

Разница между этими двумя функциями заключается в способе передачи программе
управляющих символов, таких как приостановка (CTRL-Z), прерывание и выход (CTRL-
C). В режиме `raw()` эти символы передаются программе напрямую, без генерации
сигнала. В режиме `cbreak()` эти управляющие символы интерпретируются драйвером
терминала как любой другой символ. Я лично предпочитаю использовать `raw()`, так как
могу осуществлять больший контроль над действиями пользователя.

## 4.3. echo() и noecho()
Эти функции управляют эхом символов, набираемых пользователем на терминале.
`noecho()` отключает эхо. Это нужно для того, чтобы получить больший контроль над
эхом или подавить ненужное эхо при приеме ввода от пользователя с помощью
функций `getch()` и др. Большинство интерактивных программ вызывают `noecho()` при
инициализации и выполняют эхо-передачу символов контролируемым образом. Это
дает программисту гибкость при передаче символов в любое место окна без
обновления текущих координат (`y`,`x`).

## 4.4. keypad()
Это моя любимая функция инициализации. Она позволяет считывать функциональные
клавиши, такие как F1, F2, стрелки и т.д. Почти каждая интерактивная программа
использует эту функцию, так как клавиши со стрелками являются основной частью
любого пользовательского интерфейса. Выполните `keypad(stdscr, TRUE)`, чтобы
включить эту функцию для обычного экрана (`stdscr`). Более подробно об управлении
клавишами вы узнаете в последующих разделах этого документа.

## 4.5. halfdelay()
Эта функция, хотя и не используется очень часто, иногда бывает полезной.
`halfdelay()`вызывается для включения режима половинной задержки, который похож на
режим `cbreak()` тем, что набранные символы сразу же становятся доступными для
программирования. Однако, он ожидает ввода в течение '`X`' десятых долей секунды, а
затем возвращает `ERR`, если ввод не доступен. '`X`' - это значение тайм-аута,
передаваемое в функцию `halfdelay()`. Эта функция полезна, когда вы хотите попросить
пользователя ввести данные, и если он не отвечает в течение определенного времени,
мы можем сделать что-то еще. Один из возможных примеров - тайм-аут при запросе
пароля.

## 4.6. Различные функции инициализации
Есть еще несколько функций, которые вызываются при инициализации для настройки
поведения `curses`. Они используются не так широко, как упомянутые выше. Некоторые
из них объясняются там, где это необходимо.

## 4.7. Пример 2. Пример использования функции инициализации
``` C
#include <ncurses.h>
int main()
{ 
  int ch;
  
  initscr();                  /* Запуск режима curses*/
  raw();                      /* Буферизация строк отключена*/
  keypad(stdscr, TRUE);       /* Получаем F1, F2 и т.д.*/
  noecho();                   /* Не выполняем echo(), пока делаем getch */
  
  printw("Введите любой символ, чтобы увидеть его жирным\n");
  ch = getch();               /* Если бы raw() не была вызвана.
                              * мы должны нажать Enter, прежде чем он
                              * попадает в программу */
  if(ch == KEY_F(1))          /* Без включенной клавиатуры это будет */
    printw("F1 Key pressed"); /* тоже не дойдет до нас*/.
                              /* Без noecho() некоторые уродливые escape
                              * символы могли бы быть выведены
                              *  на экран */
  else
  { 
    printw("Нажатая клавиша - ");
    attron(A_BOLD);
    printw("%c", ch);
    attroff(A_BOLD);
  }
  
  refresh();                /* Вывести на реальный экран */
  getch();                  /* Ожидание ввода данных пользователем */
  endwin();                 /* Завершить режим curses */
  
  return 0;
}
```
Эта программа не требует пояснений. Но я использовал функции, которые еще не
объяснены. Функция `getch()` используется для получения символа от пользователя. Она
эквивалентна обычной `getchar()`, за исключением того, что мы можем отключить
буферизацию строки, чтобы избежать <enter> после ввода. Подробнее о `getch()` и
чтении ключей читайте в разделе "Управление ключами". Функции attron и `attroff`
используются для включения и выключения некоторых атрибутов соответственно. В
примере я использовал их для печати символа, выделенного жирным шрифтом.
Подробно эти функции будут описаны позже.
