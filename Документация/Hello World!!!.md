# Hello World !!!
Добро пожаловать в мир `Curses`. Прежде чем мы погрузимся в библиотеку и
рассмотрим ее различные возможности, давайте напишем простую программу и
поздороваемся с миром.

## 2.1. Компиляция с использованием библиотеки NCURSES
Чтобы использовать функции библиотеки ncurses, вы должны включить `ncurses.h` в
свои программы. Для компоновки программы с ncurses необходимо добавить флаг
`-lncurses`.

```
#include <ncurses.h>
.
.
.
compile and link: gcc <program file> -lncurses
```

## Пример 1. Hello World !!!
``` C
#include <ncurses.h>

int main()
{
  initscr();                  /* Запуск режима curses */
  printw("Hello World !!!");  /* Печать Hello World */
  refresh();                  /* Вывести на реальный экран */
  getch();                    /* Ожидание ввода данных пользователем */
  endwin();                   /* Завершить режим проклятий */
  
  return 0;
}
```

## 2.2. Рассечение
Приведенная выше программа печатает "Hello World !!!" на экран и завершает работу.
Эта программа показывает, как инициализировать `curses`, выполнить манипуляции с
экраном и завершить режим `curses`. Давайте разберем ее построчно.

### 2.2.1. О функции initscr()
Функция `initscr()` инициализирует терминал в режиме `curses`. В некоторых реализациях
она очищает экран и представляет пустой экран. Для выполнения любых манипуляций
с экраном с помощью пакета `curses` необходимо сначала вызвать эту функцию. Эта
функция инициализирует систему curses и выделяет память для нашего текущего окна
(называемого `stdscr`) и некоторых других структур данных. В экстремальных случаях эта
функция может не сработать из-за недостатка памяти для выделения памяти под
структуры данных библиотеки curses.  

После этого мы можем выполнить различные инициализации для настройки
параметров `curses`. Эти детали будут описаны позже.

### 2.2.2. Загадочная refresh()
Следующая строка `printw` выводит на экран строку "Hello World !!!". Эта функция
аналогична обычной `printf` во всех отношениях, за исключением того, что она печатает
данные в окне с именем `stdscr` в текущих координатах (`y`,`x`). Поскольку наши текущие
координаты `0`,`0`, строка печатается в левом углу окна.  

Это подводит нас к загадочной функции `refresh()`. Когда мы вызвали `printw`, данные на
самом деле были записаны в воображаемое окно, которое еще не обновлено на
экране. Работа `printw` заключается в обновлении нескольких флагов и структур данных
и записи данных в буфер, соответствующий `stdscr`. Для того чтобы вывести его на
экран, нам нужно вызвать `refresh()` и сказать системе curses вывести содержимое на
экран.

Философия всего этого заключается в том, чтобы позволить программисту выполнять
несколько обновлений на воображаемом экране или окнах и обновлять их после того,
как все обновления на экране завершены. `refresh()` проверяет окно и обновляет только
ту часть, которая была изменена. Это повышает производительность и обеспечивает
большую гибкость. Но иногда это вызывает недовольство у новичков. Частой ошибкой
новичков является то, что они забывают вызвать `refresh()` после того, как выполнили
обновление через класс функций `printw()`. Я до сих пор иногда забываю ее добавить :-).

### 2.2.3. О endwin()
И, наконец, не забудьте завершить режим `curses`. Иначе ваш терминал может вести
себя странно после завершения работы программы. `endwin()` освобождает память,
занятую подсистемой `curses` и ее структурами данных, и переводит терминал в
нормальный режим. Эта функция должна быть вызвана после завершения работы в
режиме `curses`.
