# 6. Выходные функции
Думаю, вы больше не можете ждать, чтобы увидеть некоторые действия. Вернемся к
нашей одиссее по функциям `curses`. Теперь, когда curses инициализирован, давайте
взаимодействовать с миром.

Есть три класса функций, которые вы можете использовать для вывода информации на
экран:

- Класс **addch()**  : Вывод одного символа с атрибутами
- Класс **printw()** : Печать форматированного вывода, аналогичного printf().
- Класс **addstr()** : Печать строк

Эти функции могут использоваться как взаимозаменяемые, и это вопрос стиля, какой
класс использовать. Давайте рассмотрим каждую из них подробнее

## 6.1. класс функций addch()
Эти функции помещают один символ в текущее местоположение курсора и продвигают
позицию курсора. Вы можете задать символ для печати, но обычно они используются
для печати символа с некоторыми атрибутами. Атрибуты подробно описаны в
последующих разделах документа. Если символ связан с каким-либо атрибутом
(полужирный, обратный видео и т.д.), когда curses печатает символ, он печатается в
этом атрибуте.

Для того чтобы объединить символ с некоторыми атрибутами, у вас есть две
возможности:

- Путем OR'ing одного символа с нужными макросами атрибутов. Эти макросы
атрибутов можно найти в заголовочном файле `ncurses.h`. Например, если вы
хотите напечатать символ ch(типа char) жирным и подчеркнутым, вы вызовете
`addch()`, как показано ниже.  
``` C
    addch(ch | A_BOLD | A_UNDERLINE);
```
- С помощью таких функций, как `attrset()`, `attron()`, `attroff()`. Эти функции описаны в
разделе Атрибуты. Вкратце, они управляют текущими атрибутами данного окна.
После их установки символы, напечатанные в окне, ассоциируются с атрибутами
до тех пор, пока они не будут выключены

Кроме того, curses предоставляет некоторые специальные символы для графики на
основе символов. Вы можете рисовать таблицы, горизонтальные или вертикальные
линии и т.д. Все доступные символы можно найти в заголовочном файле `ncurses.h`.
Попробуйте поискать в этом файле макросы, начинающиеся с `ACS_`.

## 6.2. mvaddch(), waddch() and mvwaddch()
`mvaddch()` используется для перемещения курсора в заданную точку и последующей
печати. Таким образом, вызовы:  

``` C
move(row,col); /* moves the cursor to rowth row and colth column */
addch(ch);
```
можно заменить на:
``` C
mvaddch(row,col,ch);
```
`waddch()` аналогична `addch()`, за исключением того, что она добавляет символ в заданное
окно. (Обратите внимание, что `addch()` добавляет символ в окно `stdscr`.  

Аналогичным образом функция `mvwaddch()` используется для добавления символа в
заданное окно в заданных координатах.  

Теперь мы знакомы с базовой функцией вывода `addch()`. Но если мы хотим вывести
строку, было бы очень неудобно выводить ее символ за символом. К счастью, ncurses
предоставляет функции `printf`-подобные или `puts`-подобные.  

## 6.3. класс функций printw(
Эти функции похожи на `printf()` с дополнительной возможностью печати в любой
позиции на экране.

### 6.3.1. printw() и mvprintw
Эти две функции работают аналогично `printf()`. `mvprintw()` можно использовать для
перемещения курсора в определенную позицию и последующей печати. Если вы хотите
сначала переместить курсор, а затем напечатать с помощью функции `printw()`,
используйте сначала `move()`, а затем `printw()`, хотя я не вижу причин, почему следует
избегать использования `mvprintw()`, у вас есть гибкость в манипуляциях.

### 6.3.2. wprintw() и mvwprintw
Эти две функции аналогичны двум вышеперечисленным, за исключением того, что они
печатают в соответствующем окне, указанном в качестве аргумента.

### 6.3.3. vwprintw()
Эта функция аналогична `vprintf()`. Она может быть использована, когда необходимо
вывести переменное количество аргументов.

### 6.3.4. Простой пример printw
``` C
#include <ncurses.h> /* ncurses.h включает stdio.h */
#include <string.h>

int main()
{
  char mesg[]="Just a string";            /* сообщение, которое будет выведено на экран */
  int row,col;                            /* для хранения количества строк и *
                                          * количество столбцов экрана */
  initscr();                              /* запуск режима curses */
  getmaxyx(stdscr,row,col);               /* получить количество строк и столбцов */
  mvprintw(row/2,(col-strlen(mesg))/2,"%s",mesg);с
                                          /* выведите сообщение в центр экрана */
  mvprintw(row-2,0, "Этот экран имеет %d строк и %d столбцов\n",row,col);
  printw("Попробуйте изменить размер окна (если это возможно), а затем запустите эту программу снова");
  
  refresh();
  getch();
  endwin();
  
  return 0;
}
```
Приведенная выше программа демонстрирует, как легко использовать `printw`. Вы
просто вводите координаты и сообщение, которое должно появиться на экране, после
чего программа делает то, что вы хотите.  

Приведенная выше программа знакомит нас с новой функцией `getmaxyx()`, макросом,с
определенным в `ncurses.h`. Она выдает количество столбцов и количество строк в
данном окне. `getmaxyx()` делает это путем обновления переданных ей переменных.
Поскольку `getmaxyx()` не является функцией, мы не передаем ей указатели, а просто
передаем две целочисленные переменные.

## 6.4. Класс функций addstr()
`addstr()` используется для помещения строки символов в заданное окно. Эта функция
аналогична вызову `addch()` один раз для каждого символа в данной строке. Это
справедливо для всех функций вывода. Существуют и другие функции этого
семейства, такие как `mvaddstr()`, `mvwaddstr()` и `waddstr()`, которые подчиняются соглашению
об именовании в `curses`. (Например, `mvaddstr()` аналогична соответствующему вызову
`move()`, а затем `addstr()`. Другая функция этого семейства - `addnstr()`, которая
дополнительно принимает целочисленный параметр (скажем, `n`). Эта функция
помещает на экран не более n символов. Если `n` отрицательно, то добавляется вся
строка.

## 6.5. Небольшое предостережение
Все эти функции берут в качестве аргументов сначала координату `y`, а затем `x`. Частая
ошибка новичков - передавать `x`,`y` в таком порядке. Если вы выполняете слишком много
манипуляций с координатами (`y`,`x`), подумайте о том, чтобы разделить экран на окна и
работать с каждым из них отдельно. Окна описаны в разделе "Окна".

